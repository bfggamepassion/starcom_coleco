/**************************************************/
/*** BOSCONIAN *************************************/
/**************************************************/
// Test de timer unique
// unsigned int timer;
// timer = 0;
// timer ++;
// timer&1 == 0 = tout les 2
// timer&3 == 0 = tout les 4
// timer&7 == 0 = tout les 8
// timer&15 == 0 = tout les 16

#include <coleco.h>
#include <getput1.h>
#include <bfglib.h>

#define chrtab  0x1800 /* écran en linéaire */
#define chrgen  0x0000 /* table des caractères */
#define coltab  0x2000 /* couleur des caractères */
#define sprtab  0x3800 /* sprite_pattern_table */
#define sprgen  0x1b00 /* sprite_attribute_table */
#define buffer  0x1c00 /* buffer screen 2 */

#define S_TRUE 1
#define S_FALSE 0

#define MAXSCROLLOBJ 8

#define TILE_MOTHERSHIPV 0
#define TILE_MOTHERSHIPH 1
#define TILE_BLANK 2

/* 9 types graphiques d'étoiles (ANIMATION) */
#define TILE_STARFIELD1 10 
#define TILE_STARFIELD2 11 
#define TILE_STARFIELD3 12 
#define TILE_STARFIELD4 18 
#define TILE_STARFIELD5 19 
#define TILE_STARFIELD6 20 
#define TILE_STARFIELD7 26 
#define TILE_STARFIELD8 27 
#define TILE_STARFIELD9 28 

#define NOMOVE_MINE 22*4
#define NOMOVE_AST1 23*4
#define NOMOVE_AST2 24*4
#define NOMOVE_EXPLOSION 25*4
#define ALIEN_BOOMERANG 32
#define ALIEN_TRIANGLE 40

#define INACTIF 204
#define INVISIBLE 203

#define HAUT -1
#define BAS 1
#define GAUCHE -1
#define DROITE 1
#define STATIQUE 0

#define PLAYERSTARTX 94
#define PLAYERSTARTY 94
#define MAXENNEMYBULLET 5
#define MAXALIEN 5
#define MAXNOMOVE 6

#define BUL_ACTIVE 0x80
#define BUL_UP 0x1
#define BUL_LEFT 0x2

#define ACTION_NULL			0
#define ACTION_LOOSE_LIFE	1

#define SHOW_SPLASH0 0
#define SHOW_STORY 1
#define SHOW_TITLE 2
#define	INGAME 3
#define NEXT_LEVEL 4
#define GAME_OVER 5

extern const byte tankAnimationV[];
extern const byte tankAnimationH[];

extern const byte SPLASH0_PATTERNRLE[];
extern const byte SPLASH0_COLORRLE[];
extern const byte SPLASH0_NAMERLE[];

extern const byte SPLASH1_PATTERNRLE[];
extern const byte SPLASH1_COLORRLE[];
extern const byte SPLASH1_NAMERLE[];

extern const byte SPLASH2_PATTERNRLE[];
extern const byte SPLASH2_COLORRLE[];
extern const byte SPLASH2_NAMERLE[];

extern const byte TITLE_PATTERNRLE[];
extern const byte TITLE_COLORRLE[];
extern const byte TITLE_NAMERLE[];

extern const byte PATTERNRLE[];
extern const byte COLORRLE[];
extern const byte SPATTERNRLE[];
extern const byte tiles_Init[];
extern const byte* const tiles_Pointer[];
extern const byte testTile[];
extern const byte pod_position[];
extern const byte collisionv[];
extern const byte collisionh[];
extern const byte fondRadar[];

extern const char* const levels_Pointer[];

char mynmi;
char workflow;
char mydelay;

byte tankAnimationPointer;
byte tankAnimationSpeed;
byte tankCurrentFrameV;
byte tankCurrentFrameH;

byte traceSprite;
byte action;

// Position courante du point de référence
int refx;
int refy;

byte currentFlicker;
byte render;
byte currentNmi;
byte tmp;

byte radarPosx;
byte radarPosy;
byte radarOldCar;

char currentStarAnim;

int cpt;
byte go;

char motherShipVisible;

unsigned int timer;

//byte timer2;
//byte timer8;
//byte timer64;

byte nbMothershipLevel;

sprite_t bsprites[32];

// Le static x est entre 0 et 26
// Le static y est entre 0 et 20
typedef struct
{
	byte p;	// Pattern à utiliser
	char staticx; // Position par rapport au point de référence
	char staticy; // Position par rapport au point de référence
	byte pod; // Pour les motherShips
} s_scrollObj;

s_scrollObj scrollObj[MAXSCROLLOBJ];

typedef struct
{
	char staticx; // Position par rapport au point de référence
	char staticy; // Position par rapport au point de référence
} s_star;

s_star stars[5];

typedef struct
{
	byte sprno1;
    byte sprno2;
	char directionH;
	char directionV;
	byte char_haut_gauche;
	byte char_haut_droite;
	byte char_bas_gauche;
	byte char_bas_droite;
	unsigned score;	
	byte timerShoot;
} s_player;

s_player player;

// Libre mvtx = 0 et mvt y = 0
typedef struct
{	
	char mvtx;
	char mvty;	
	byte sprno;
	byte currentChar;
} s_shoot;

s_shoot shoot[4];

typedef struct
{
	byte flags;
    byte sprno;
    byte dx,dy;
    int err;
} s_ennemyBullet ;

s_ennemyBullet ennemyBullet[MAXENNEMYBULLET];


typedef struct
{
	byte typeAlien;
	byte flags;
    byte sprno;
    byte dx,dy;
	byte finalx,finaly;
    int err;
} s_alien;

s_alien alien[MAXALIEN];	

typedef struct
{
	byte actif;
	byte sprno;
} s_nomoveObject;

s_nomoveObject nomoveObject[MAXNOMOVE]; // Objets qui ne bougent pas d'eux même.

/*
char getFreeSprite()
{
	byte i;
		
	odd+=8;
	if (odd>=32) odd = 0;
	
	for (i=odd;i<32;i++)
		if (sprites[i].y==INACTIF) 
			return i;	
	for (i=0;i<odd;i++)
		if (sprites[i].y==INACTIF) 
			return i;
	
	return -1;
}*/

/*
void cv_set_vint_active(char active) {
        vdp_out(0x1, cv_vdpreg[1] = (active ? 0x20 : 0x0) | (cv_vdpreg[1] & ~0x20));
}
*/

void createEnnemyBullet(byte pattern,byte colour,int x0,int y0,int x1,int y1)
{
	int i;
	char s;
	
	for(i=0;i<MAXENNEMYBULLET;i++) {
		if(ennemyBullet[i].flags&BUL_ACTIVE) continue;
		/* found an unused bullet, so let's set it up.*/
		//bullet[i].sprite=newsprite(i,x0,y0);
		s = getFreeSprite();
		if (s!=-1)
		{
			ennemyBullet[i].sprno = s;		
			sprites[s].pattern=pattern;
			sprites[s].colour=colour;
			sprites[s].x=x0;
			sprites[s].y=y0;
			ennemyBullet[i].flags=BUL_ACTIVE;
			ennemyBullet[i].flags|=(x0<x1)?0:BUL_LEFT;
			ennemyBullet[i].flags|=(y0<y1)?0:BUL_UP;
			ennemyBullet[i].dx=(x0<x1)?x1-x0:x0-x1;
			ennemyBullet[i].dy=(y0<y1)?y1-y0:y0-y1;
			ennemyBullet[i].err=ennemyBullet[i].dx-ennemyBullet[i].dy;
		
			return;
		}
	}
}

void initAlien()
{
	byte i;
	
	for (i=0;i<MAXALIEN;i++)
	{
		alien[i].flags=0;
	}
}

void createAlien(byte typeAlien,int x0,int y0,int x1,int y1)
{
	int i;
	char s;
	
	for(i=0;i<MAXALIEN;i++) {
		if(alien[i].flags&BUL_ACTIVE) continue;
		/* found an unused bullet, so let's set it up.*/
		//bullet[i].sprite=newsprite(i,x0,y0);
		s = getFreeSprite();
		if (s!=-1)
		{
			alien[i].sprno = s;		
			sprites[s].pattern=typeAlien<<2;
			sprites[s].colour=3;
			if (typeAlien==ALIEN_TRIANGLE) sprites[s].colour=13;
			sprites[s].x=x0;
			sprites[s].y=y0;
			alien[i].finalx = x1;
			alien[i].finaly = y1;
			alien[i].typeAlien = typeAlien;
			alien[i].flags=BUL_ACTIVE;
			alien[i].flags|=(x0<x1)?0:BUL_LEFT;
			alien[i].flags|=(y0<y1)?0:BUL_UP;
			alien[i].dx=(x0<x1)?x1-x0:x0-x1;
			alien[i].dy=(y0<y1)?y1-y0:y0-y1;
			alien[i].err=alien[i].dx-alien[i].dy;
		
			return;
		}
	}
}

void reinitAlien(byte i,int x0,int y0,int x1,int y1)
{
			alien[i].finalx = x1;
			alien[i].finaly = y1;
			alien[i].flags=BUL_ACTIVE;
			alien[i].flags|=(x0<x1)?0:BUL_LEFT;
			alien[i].flags|=(y0<y1)?0:BUL_UP;
			alien[i].dx=(x0<x1)?x1-x0:x0-x1;
			alien[i].dy=(y0<y1)?y1-y0:y0-y1;
			alien[i].err=alien[i].dx-alien[i].dy;
}

byte returnAlienPattern(byte typeAlien,char mvtx,char mvty)
{
		if ((mvtx==0) && (mvty<0)) return (typeAlien+0)<<2;
		else if ((mvtx>0) && (mvty<0)) return (typeAlien+1)<<2;
		else if ((mvtx>0) && (mvty==0)) return (typeAlien+2)<<2;
		else if ((mvtx>0) && (mvty>0)) return (typeAlien+3)<<2;
		else if ((mvtx==0) && (mvty>0)) return (typeAlien+4)<<2;
		else if ((mvtx<0) && (mvty>0)) return (typeAlien+5)<<2;
		else if ((mvtx<0) && (mvty==0)) return (typeAlien+6)<<2;
		else if ((mvtx<0) && (mvty<0)) return (typeAlien+7)<<2;	

		return 0;
}

/*
void updateAlien(byte id)
{
	byte s=alien[id].sprno;
	byte dx=alien[id].dx;
	byte dy=alien[id].dy;
	int e2;

	
	if((alien[id].flags&BUL_ACTIVE)==0) return; // not active.
	
	if(sprites[s].x>192 || sprites[s].y>191 ) {
		alien[id].flags=0; // sprite inactive.
		sprites[s].y=INACTIF; // off screen.
		return;
	}
	e2=alien[id].err<<1;
	if( e2 > -dy) {
		alien[id].err-=dy;
		sprites[s].x+=(alien[id].flags&BUL_LEFT)?-1:1;
	}
	if( e2 < dx ) {
		alien[id].err+=dx;
		sprites[s].y+=(alien[id].flags&BUL_UP)?-1:1;
	}

	if ((timer&3)==0) // pti coup de boost tout les 2 tours
	{
		e2=alien[id].err<<1;
		if( e2 > -dy) {
			alien[id].err-=dy;
			sprites[s].x+=(alien[id].flags&BUL_LEFT)?-1:1;
		}
		if( e2 < dx ) {
			alien[id].err+=dx;
			sprites[s].y+=(alien[id].flags&BUL_UP)?-1:1;
		}
	}
	sprites[s].pattern = returnAlienPattern(alien[id].typeAlien,(alien[id].flags&BUL_LEFT)?-1:1,(alien[id].flags&BUL_UP)?-1:1);
	
	if ((timer&1)==0)
	{
		if (player.directionH == DROITE)
			sprites[s].x-=2;
		else
			if (player.directionH == GAUCHE)
				sprites[s].x+=2;

		if (player.directionV == HAUT)
			sprites[s].y+=2;
		else
			if (player.directionV == BAS)
			sprites[s].y-=2;						
		
		if(sprites[s].x>192 || sprites[s].y>191 ) {
			alien[id].flags=0; // sprite inactive.
			sprites[s].y=INACTIF; // off screen.
			return;
		}	
	}
}
*/

void updateAlien(byte id)
{
	s_alien *this_alien;
	byte *this_alien_typeAlien;
	byte *this_alien_flags;
    byte *this_alien_sprno;
    byte *this_alien_dx;
	byte *this_alien_dy;
    int  *this_alien_err;
	
	sprite_t *this_sprite;
	byte *this_sprite_x;
	byte *this_sprite_y;
	byte *this_sprite_pattern;
	
	int e2;
		
	this_alien = &alien[id];
	this_alien_sprno = &this_alien->sprno;
	this_alien_flags = &this_alien->flags;
	this_alien_err = &this_alien->err;
	this_alien_typeAlien = &this_alien->typeAlien;
	this_alien_dx = &this_alien->dx;
	this_alien_dy = &this_alien->dy;
	
	this_sprite = &sprites[(*this_alien_sprno)];
	this_sprite_x = &this_sprite->x;
	this_sprite_y = &this_sprite->y;
	this_sprite_pattern = &this_sprite->pattern;
	
	
	if(((*this_alien_flags)&BUL_ACTIVE)==0) return; // not active.
	
	if((*this_sprite_x)>192 || (*this_sprite_y)>191 ) {
		(*this_alien_flags)=0; // sprite inactive.
		(*this_sprite_y)=INACTIF; // off screen.
		return;
	}
	e2=(*this_alien_err)<<1;
	if( e2 > -(*this_alien_dy)) {
		(*this_alien_err)-=(*this_alien_dy);
		(*this_sprite_x)+=((*this_alien_flags)&BUL_LEFT)?-1:1;
	}
	if( e2 < (*this_alien_dx) ) {
		(*this_alien_err)+=(*this_alien_dx);
		(*this_sprite_y)+=((*this_alien_flags)&BUL_UP)?-1:1;
	}

	if ((timer&3)==0) // pti coup de boost tout les 2 tours
	{
		e2=(*this_alien_err)<<1;
		if( e2 > -(*this_alien_dy)) {
			(*this_alien_err)-=(*this_alien_dy);
			(*this_sprite_x)+=((*this_alien_flags)&BUL_LEFT)?-1:1;
		}
		if( e2 < (*this_alien_dx) ) {
			(*this_alien_err)+=(*this_alien_dx);
			(*this_sprite_y)+=((*this_alien_flags)&BUL_UP)?-1:1;
		}
	}
	(*this_sprite_pattern) = returnAlienPattern((*this_alien_typeAlien),((*this_alien_flags)&BUL_LEFT)?-1:1,((*this_alien_flags)&BUL_UP)?-1:1);
	
	if ((timer&1)==0)
	{
		if (player.directionH == DROITE)
			(*this_sprite_x)-=2;
		else
			if (player.directionH == GAUCHE)
				(*this_sprite_x)+=2;

		if (player.directionV == HAUT)
			(*this_sprite_y)+=2;
		else
			if (player.directionV == BAS)
			(*this_sprite_y)-=2;						
		
		if((*this_sprite_x)>192 || (*this_sprite_y)>191 ) {
			(*this_alien_flags)=0; // sprite inactive.
			(*this_sprite_y)=INACTIF; // off screen.
			return;
		}	
	}
}

void gererAIAlien()
{	
	byte i;
	int deltax;
	int deltay;
	
	byte newDestx;
	byte newDesty;
	
	s_alien *this_alien;
//	byte *this_alien_typeAlien;
	byte *this_alien_flags;
    byte *this_alien_sprno;
//    byte *this_alien_dx;
//	byte *this_alien_dy;
	byte *this_alien_finalx;
	byte *this_alien_finaly;
//    int  *this_alien_err;
	
	sprite_t *this_sprite;
	byte *this_sprite_x;
	byte *this_sprite_y;
//	byte *this_sprite_pattern;
				
	// Ici on va gérer leur intelligence Artificielle
	
	for (i=0;i<MAXALIEN;i++)
	{
	
		this_alien = &alien[i];
		this_alien_sprno = &this_alien->sprno;
		this_alien_flags = &this_alien->flags;
//		this_alien_err = &this_alien->err;
//		this_alien_typeAlien = &this_alien->typeAlien;
//		this_alien_dx = &this_alien->dx;
//		this_alien_dy = &this_alien->dy;
		this_alien_finalx = &this_alien->finalx;
		this_alien_finaly = &this_alien->finaly;

		
		this_sprite = &sprites[(*this_alien_sprno)];
		this_sprite_x = &this_sprite->x;
		this_sprite_y = &this_sprite->y;
//		this_sprite_pattern = &this_sprite->pattern;

		// Tout les 8 on remet l'alien sur le bon chemin
		if ( ((timer&15)==0) && (((*this_alien_flags)&BUL_ACTIVE)!=0) )
		{
			if (rnd_byte(0,100)<10)
				createEnnemyBullet(21<<2,10,(*this_sprite_x)+8,(*this_sprite_y)+8,PLAYERSTARTX,PLAYERSTARTY);	
		}
		
		if (((timer&7)==0) && (((*this_alien_flags)&BUL_ACTIVE)!=0)) reinitAlien(i,(*this_sprite_x),(*this_sprite_y),(*this_alien_finalx),(*this_alien_finaly));
		else
		// Si l'alien à atteind sa destination, on va lui en trouver une nouvelle
		if (((*this_alien_flags)&BUL_ACTIVE)!=0)
		{
			if ((*this_sprite_x)>(*this_alien_finalx))
				deltax = (*this_sprite_x)-(*this_alien_finalx);
			else
				deltax = (*this_alien_finalx)-(*this_sprite_x);
			
			if ((*this_sprite_y)>(*this_alien_finaly))
				deltay = (*this_sprite_y)-(*this_alien_finaly);
			else
				deltay = (*this_alien_finaly)-(*this_sprite_y);
					
			
			if ( (deltax<4) && (deltay<4) )
			{
				newDestx = sprites[0].x;
				newDesty = sprites[0].y;
				
				if (rnd_byte(0,100)>50)
					newDesty += rnd_byte(20,40);
				else
					newDesty -= rnd_byte(20,40);

				if (rnd_byte(0,100)>50)
					newDestx += rnd_byte(20,40);
				else
					newDestx -= rnd_byte(20,40);
				
				reinitAlien(i,(*this_sprite_x),(*this_sprite_y),rnd_byte(0,200),rnd_byte(0,192));
			}
		}
			
		
		// On fait bouger
		updateAlien(i);
	}
}

void declencherAlien()
{	
	// Ici on va créer les aliens
	// --> Si il n'y à pas de motherShip à l'écran
	// --> On va créer selon le niveau de difficulté des aliens
	byte startx;
	byte starty;
	byte r;
	
	r=rnd_byte(0,100);
	
	startx = 0;
	starty = 0;
	
	//if (motherShipVisible==-1)
	if ((timer&127)==0)
	{
		if (rnd_byte(0,100)<80)
		{
			if (player.directionH == DROITE)
				startx = 190;
			else
			if (player.directionH == GAUCHE)
				startx = 0;

			if (player.directionV == HAUT)
				starty = 0;
			else
			if (player.directionV == BAS)
				starty = 180;

		}
			if (r<50) createAlien(ALIEN_BOOMERANG,startx,starty,150,150);
			else createAlien(ALIEN_TRIANGLE,startx,starty,50,50);
	}
	// Et on les fait réfléchir
	gererAIAlien();
}


void initNomoveObject()
{
	byte i;
	for (i=0;i<MAXNOMOVE;i++)
		nomoveObject[i].actif = 0;
}

void createNomoveObject(byte x,byte y,byte pattern)
{
	char s,i;
	
	s = getFreeSprite();
	if (s!=-1)
	{
		for (i=0;i<MAXNOMOVE;i++)
		{
			if (nomoveObject[i].actif==0)
			{
				//if (pattern==NOMOVE_EXPLOSION) center_string(0,str(i));
				//pause();
				nomoveObject[i].actif = 1;
				nomoveObject[i].sprno = s;
				sprites[s].x = x;
				sprites[s].y = y;
				sprites[s].pattern = pattern;
						
				if (pattern==NOMOVE_EXPLOSION) sprites[s].colour = 6;
				else if (pattern==NOMOVE_AST1) sprites[s].colour = 11;
				else if (pattern==NOMOVE_AST2) sprites[s].colour = 12;
				else sprites[s].colour = 5;	
				
				break;
			}
		}
	}
}

void updateNomoveObject(byte i)
{
	char decalx;
	char decaly;
	
	sprite_t *this_sprite;
	byte *this_sprite_x;
	byte *this_sprite_y;	
	byte *this_sprite_pattern;
	
	s_nomoveObject *this_nomoveObject;
	byte *this_nomoveObject_actif;
	byte *this_nomoveObject_sprno;
	
	
	decalx=decaly=0;
	
	if (player.directionH == DROITE)
		decalx=-1;
	else
	if (player.directionH == GAUCHE)
		decalx=1;

	if (player.directionV == HAUT)
		decaly=1;
	else
	if (player.directionV == BAS)
		decaly=-1;						

//	for (i=0;i<MAXNOMOVE;i++)
//	{
		this_nomoveObject = &nomoveObject[i];
		this_nomoveObject_actif = &this_nomoveObject->actif;
	
		if ((*this_nomoveObject_actif) == 1)
		{
			this_nomoveObject_sprno = &this_nomoveObject->sprno;
			this_sprite = &sprites[(*this_nomoveObject_sprno)];
			this_sprite_x = &this_sprite->x;
			this_sprite_y = &this_sprite->y;
			this_sprite_pattern = &this_sprite->pattern;
						
			(*this_sprite_x)+=decalx;
			(*this_sprite_y)+=decaly;
				
			// Faire l'animation en cas d'explosion !!
			if ((*this_sprite_pattern)>24*4) //explosion !!
			{
				if ((timer&7)==0)
				{
					if ((*this_sprite_pattern)<27*4)
					{
						(*this_sprite_pattern)+=4;
					}
					else
					{
						(*this_nomoveObject_actif)=0; // sprite inactive.
						(*this_sprite_y)=INACTIF; // off screen.
					}
				}
			}
			// Fin animation
				
			if((*this_sprite_x)>192 /*|| sprites[nomoveObject[i].sprno].x==0*/ || (*this_sprite_y)>191 /*|| sprites[nomoveObject[i].sprno].y==0*/) {
				(*this_nomoveObject_actif)=0; // sprite inactive.
				(*this_sprite_y)=INACTIF; // off screen.								
			}
		}
	//}			
}

void gererAINoMoveObject()
{	
	byte i;
	// Ici on va gérer leur intelligence Artificielle
	
	for (i=0;i<MAXNOMOVE;i++)
	{
		// Si l'alien à atteind sa destination, on va lui en trouver une nouvelle
		
		// On fait bouger
		updateNomoveObject(i);
	}
}

void declencherNoMoveObject()
{	
	// Ici on va créer les nomoves
	// --> Si il n'y à pas de motherShip à l'écran
	// --> On va créer selon le niveau de difficulté, timer et la direction du joueur, des nomoves
	byte startx;
	byte starty;
	byte r;
	startx = 0;
	starty = 0;
	
	if (motherShipVisible==-1)
	if ((timer&31)==0)
	{
		if (rnd_byte(0,100)<80)
		{
			if ((player.directionV == BAS))
			{
				startx = rnd(0,160);
				starty = 191;
			}
			else
			if ((player.directionV == HAUT))
			{
				startx = rnd(0,160);
				starty = 0;
			}
			else
			if ((player.directionH == DROITE))
			{
				starty = rnd(0,160);
				startx = 190;
			}
			else
			if ((player.directionH == GAUCHE))
			{
				starty = rnd(0,160);
				startx = 0;
			}
			/*
			if (player.directionH == DROITE)
				startx = 190;
			else
			if (player.directionH == GAUCHE)
				startx = 0;

			if (player.directionV == HAUT)
				starty = 0;
			else
			if (player.directionV == BAS)
				starty = 180;
			*/
			r = rnd_byte(0,100);
			if (r<33) createNomoveObject(startx,starty,NOMOVE_MINE);
			else if (r<66) createNomoveObject(startx,starty,NOMOVE_AST1);
			else createNomoveObject(startx,starty,NOMOVE_AST2);
		}
		
		
	}
	// Et on les fait réfléchir
	gererAINoMoveObject();
}

void initEnnemyBullet()
{
	byte i;
	
	for (i=0;i<MAXENNEMYBULLET;i++)
		ennemyBullet[i].flags=0;
}

void updatebullet(byte id)
{
	s_ennemyBullet *this_bullet;
	byte *this_bullet_flags;
    byte *this_bullet_sprno;
    byte *this_bullet_dx;
	byte *this_bullet_dy;
    int  *this_bullet_err;
	
	sprite_t *this_sprite;
	byte *this_sprite_x;
	byte *this_sprite_y;
	byte *this_sprite_pattern;
	
	
	byte boucle;
	byte i;
	int e2;
	
	this_bullet = &ennemyBullet[id];
	this_bullet_sprno = &this_bullet->sprno;
	this_bullet_flags = &this_bullet->flags;
	this_bullet_err = &this_bullet->err;
	this_bullet_dx = &this_bullet->dx;
	this_bullet_dy = &this_bullet->dy;
	
	this_sprite = &sprites[(*this_bullet_sprno)];
	this_sprite_x = &this_sprite->x;
	this_sprite_y = &this_sprite->y;
	this_sprite_pattern = &this_sprite->pattern;

	

	//byte s=ennemyBullet[id].sprno;
	//byte p=sprites[s].pattern;
	//byte dx=ennemyBullet[id].dx;
	//byte dy=ennemyBullet[id].dy;
	

	
	boucle = 1;
	

	if(((*this_bullet_flags)&BUL_ACTIVE)==0) return; // not active.
	
	if (((*this_sprite_pattern)>=(28<<2)) && ((*this_sprite_pattern)<=(31<<2))) boucle = 3;
	
	for (i=0;i<boucle;i++)
	{
	if((*this_sprite_x)>192 || (*this_sprite_y)>191) {
		(*this_bullet_flags)=0; // sprite inactive.
		(*this_sprite_y)=INACTIF; // off screen.
		return;
	}
	e2=(*this_bullet_err)<<1;
	if( e2 > -(*this_bullet_dy)) {
		(*this_bullet_err)-=(*this_bullet_dy);
		(*this_sprite_x)+=((*this_bullet_flags)&BUL_LEFT)?-1:1;
	}
	if( e2 < (*this_bullet_dx) ) {
		(*this_bullet_err)+=(*this_bullet_dx);
		(*this_sprite_y)+=((*this_bullet_flags)&BUL_UP)?-1:1;
	}
	

	}
	if ((timer&1)==0)
	{
		if (player.directionH == DROITE)
			(*this_sprite_x)-=1;
		else
			if (player.directionH == GAUCHE)
				(*this_sprite_x)+=1;

		if (player.directionV == HAUT)
			(*this_sprite_y)+=1;
		else
			if (player.directionV == BAS)
			(*this_sprite_y)-=1;						
		
		if((*this_sprite_x)>192 || (*this_sprite_y)>191) {
			(*this_bullet_flags)=0; // sprite inactive.
			(*this_sprite_y)=INACTIF; // off screen.
			return;
		}	
	}
}

void initShoot()
{
	byte i;
	
	for (i=0;i<4;i++) {shoot[i].mvtx = 0;shoot[i].mvty = 0;shoot[i].currentChar=0;}
}


void renderMotherShip(char t,char n)
{
	byte p;
	int calcx;
	int calcy;
	byte spriteRef;
	int decalx;
	int decaly;
	int rx;
	int ry;
	byte l;

	decalx = 0;
	decaly = 0;
	spriteRef = 0;
	 
	calcx = refx+((scrollObj[n].staticx)<<3);
	calcy = refy+((scrollObj[n].staticy)<<3);
				
	scrollObj[n].pod = scrollObj[n].pod & 127; // Le motherShip est invisible, les pod aussi !!
	
	if ( (calcx>-12) && (calcx<24) )			// Si le mothership est visible
	{			
		if ( (calcy>-12) && ((calcy)<24) )
		{	
			scrollObj[n].pod = scrollObj[n].pod | 128; // Le motherShip est visible, les pod aussi
			//disable_nmi();
			put_frame_crop_H24(tiles_Pointer[t],calcx,calcy,tiles_Init[(t<<2)+1],tiles_Init[(t<<2)+2]);	
			//put_frame(tiles_Pointer[t],calcx,calcy,tiles_Init[(t<<2)+1],tiles_Init[(t<<2)+2]);
			motherShipVisible = t;
			// Affichage des pods de ce mothership
			// Par rapport à une zone de sprite existante !
			//enable_nmi();
			
			// Si il est visible, il peut tirer !!
			//if (((calcx+6)>0) && ((calcy+6)>0) && ((timer&31)==0))
				//createEnnemyBullet((calcx<<3)+44,(calcy<<3)+44,PLAYERSTARTX,PLAYERSTARTY);

			calcx = calcx<<3;
			calcy = calcy<<3;
				// Affichage des pods
				l = 1;
				for (p=0;p<6;p++)
				{
					if (t==TILE_MOTHERSHIPV) spriteRef = p+10; else spriteRef = p+16;
					
					if (((scrollObj[n].pod & l) == l) ) // Si le pod doit être affiché car non détruit
					{
						if (t==TILE_MOTHERSHIPV)
						{
							decalx = pod_position[(p<<1)];
							decaly = pod_position[(p<<1)+1];
						}
						else
						{
							decalx = pod_position[(p<<1)+12];
							decaly = pod_position[(p<<1)+12+1];
						}	
									
						rx = calcx+decalx;
						ry = calcy+decaly;
						
						if (
							(((rx)>=0) && ((rx)<=176)) // Si le sprite est dans l'écran
							&&
							(((ry)>=-16) && ((ry)<=196))
		
						)
						{
							sprites[spriteRef].x = rx;
							sprites[spriteRef].y = ry;
						}					
						else
						{
							sprites[spriteRef].y = INVISIBLE;
						}
					}
					else
					{
						sprites[spriteRef].y = INVISIBLE;
					}
					
					l = l<<1;
				}	
				
				// Affichage du cache tank
				// Gestion des tirs
						if (t==TILE_MOTHERSHIPV)
						{
							decalx = 40;
							decaly = 32-1;
							rx = calcx+decalx;
							ry = calcy+decaly;
							if (
							(((rx)>=0) && ((rx)<=176)) // Si le sprite est dans l'écran
							&&
							(((ry)>=-16) && ((ry)<=196))
		
							)
							{
								sprites[23].x = rx;
								sprites[23].y = ry;
								
								// Tir droit ?
								if ((timer&31)==0)
								{
									//center_string(0,str(rx));pause();
									if (ry<(94-16)) createEnnemyBullet(29<<2,15,rx-3,ry,rx-3,ry+16);
									else if (ry>(94+16)) createEnnemyBullet(28<<2,15,rx-3,ry,rx-3,ry-16);
								}
							}					
							else
							{
								sprites[23].y = INVISIBLE;
							}
						}
						else
						{
							decalx = 40;
							decaly = 40-1;
							rx = calcx+decalx;
							ry = calcy+decaly;
							if (
							(((rx)>=0) && ((rx)<=176)) // Si le sprite est dans l'écran
							&&
							(((ry)>=-16) && ((ry)<=196))
		
							)
							{
								sprites[22].x = rx;
								sprites[22].y = ry;
								
								// Tir droit ?
								if ((timer&31)==0)
								{
									//center_string(0,str(rx));pause();
									if (rx<(94-16)) createEnnemyBullet(30<<2,15,rx,ry-3,rx+16,ry-3);
									else if (rx>(94+16)) createEnnemyBullet(31<<2,15,rx,ry-3,rx-16,ry-3);
								}
							}else
														{
								sprites[22].y = INVISIBLE;
							}
						}	
						

				
				
		}
	}	
}

void renderHUD()
{
	print_at(24,0,"HI-SCORE");
	print_at(24,2,"1UP");
	print_at(24,23,"ROUND 1");
}

void initRadar()
{
	byte x,y,so;	
	nbMothershipLevel=0;
/*
	
	for (x=24;x<32;x++)
		for(y=7;y<21;y++)
		{
			put_char(x,y,0);
		}
	enable_nmi();*/
	
	disable_nmi();
	put_frame0(fondRadar,24,7,8,15);
	enable_nmi();
	
	for (so=0;so<MAXSCROLLOBJ;so++)
	{
		if ( (scrollObj[so].p!=INACTIF) /*&&  (scrollObj[so].p<10)*/ )
		{
			// Position x + Position X sur scrollobject / ratio ecran (224 caractères pour 32 en x = 7+1 Ecrans --> 224/8 car de radar = 28 RATIO
			// Position Y + Position Y sur scrollobject / ratio ecran (168 caractères pour 24 en y = 7+1 Ecrans --> 168/14 car de radar = 12 RATIO	
			x = 24+((scrollObj[so].staticx<<3)/28);
			y = 7+((scrollObj[so].staticy<<3)/12);
			nbMothershipLevel++;

			//if (x>31) x = 31;
			//if (y>23) y = 23;
			
			//disable_nmi();
			put_char_protected(x,y,1);
			//enable_nmi();
		}
	}
	
	
	radarPosx = 24 + ((refx*-1) /28);
	radarPosy =  7 + ((refy*-1) /12);
	
	if (radarPosx>31) radarPosx = 31;
	if (radarPosy>23) radarPosy = 23;
	
	//disable_nmi();
	radarOldCar = get_char_protected(radarPosx,radarPosy);	
	put_char_protected(radarPosx,radarPosy,3);
	//enable_nmi();	
}

void renderRadar()
{	
	disable_nmi();
	put_char(radarPosx,radarPosy,radarOldCar);
	enable_nmi();

	radarPosx = 24 + (((refx*-1)) /28);
	radarPosy =  7 + (((refy*-1)) /12);
	
	if (radarPosx>31) radarPosx = 31;
	if (radarPosy>23) radarPosy = 23;

	//disable_nmi();
	radarOldCar = get_char_protected(radarPosx,radarPosy);	
	put_char_protected(radarPosx,radarPosy,3);
	//enable_nmi();
}

void renderScrollObj()
{
	byte i;
	s_scrollObj *this_scrollObj;
	byte *this_scrollObj_p;
	
		for (i=0;i<MAXSCROLLOBJ;i++)
		{
			this_scrollObj = &scrollObj[i];
			this_scrollObj_p = &this_scrollObj->p;
			
			// On render les mothership
			if ( ((*this_scrollObj_p)==TILE_MOTHERSHIPV) || ((*this_scrollObj_p)==TILE_MOTHERSHIPH) )
			{
				renderMotherShip((*this_scrollObj_p),i);				
			}
		}
}

void initScrollObj()
{
	byte i;
	
	for (i=0;i<MAXSCROLLOBJ;i++) 
	{
		scrollObj[i].p = INACTIF;
		scrollObj[i].pod = 1+2+4+8+16+32;
	}
}

char getFreeScrollObj()
{
	byte i;
	
	for (i=0;i<MAXSCROLLOBJ;i++) 
		if (scrollObj[i].p == INACTIF) return i;

	return -1;
}

void initSprites()
{
	byte i;

	for (i=0;i<32;i++) {sprites[i].y = INACTIF;sprites[i].x = 0;}
	
	// Réservation des sprites de pods 10 à 21
	// Cache tank 22 --> H et 23 --> V
	for (i=10;i<24;i++)
	{
		sprites[i].x = 0;
		sprites[i].y = INVISIBLE;
		sprites[i].pattern = 16<<2;
		sprites[i].colour = 14;
	}
}

void initPlayer()
{
	player.sprno1 = 0;
	sprites[player.sprno1].x = PLAYERSTARTX;
	sprites[player.sprno1].y = PLAYERSTARTY;
	sprites[player.sprno1].pattern = 0;
	sprites[player.sprno1].colour = 6;
	player.sprno2 = 1;
	sprites[player.sprno2].x = PLAYERSTARTX;
	sprites[player.sprno2].y = PLAYERSTARTY;
	sprites[player.sprno2].pattern = 4;
	sprites[player.sprno2].colour = 15;
	player.directionV = STATIQUE;
	player.directionH = STATIQUE;
	
	player.timerShoot = 0;
}

char getFreeShoot()
{
	char i;
	
	for (i=0;i<4;i++)
	{
		if ( (shoot[i].mvtx==0) && (shoot[i].mvty==0) ) return i;
	}
	
	return -1;
}

void moveShoot()
{
	byte i;
	byte cx,cy;
	
	s_shoot *this_shoot;
	byte 	*this_shoot_sprno;
	char	*this_shoot_mvtx;
	char	*this_shoot_mvty;
	
	sprite_t *this_sprite;
	byte 	 *this_sprite_x;
	byte 	 *this_sprite_y;
	
	for (i=0;i<4;i++)
	{
		this_shoot = &shoot[i];
		this_shoot_sprno = &this_shoot->sprno;
		this_shoot_mvtx = &this_shoot->mvtx;
		this_shoot_mvty = &this_shoot->mvty;
		this_sprite = &sprites[(*this_shoot_sprno)];
		this_sprite_x = &this_sprite->x;
		this_sprite_y = &this_sprite->y;
		
		if ( ((*this_shoot_mvtx)!=0) || ((*this_shoot_mvty)!=0) )
		{
			(*this_sprite_x) += (*this_shoot_mvtx)<<1;
			(*this_sprite_y) += (*this_shoot_mvty)<<1;
			
			// On va bouger également par rapport au scrolling
			if ((timer&7)==0)
			{			
			
					if ((*this_shoot_mvtx)==0) // Si le shoot ne bouge pas horizontalement
					{
						if (player.directionH == DROITE)
							(*this_sprite_x)-=8;
						else
						if (player.directionH == GAUCHE)
							(*this_sprite_x)+=8;
					}

					if ((*this_shoot_mvty)==0) // Si le shoot ne bouge pas verticalement
					{
						if (player.directionV == HAUT)
							(*this_sprite_y)+=8;
						else
						if (player.directionV == BAS)
							(*this_sprite_y)-=8;				
					}					
			}
			
			cx = ((*this_sprite_x)+4)>>3;
			cy = ((*this_sprite_y)+4)>>3;
			if ((cx<25) && (cy<23) )
			{
				disable_nmi();
				shoot[i].currentChar = get_char(cx,cy);
				enable_nmi();
			}
			
			if (
				((*this_sprite_x) > 196)
			   || ((*this_sprite_y)> 192)			   
			   )
			{
				(*this_shoot_mvtx) = 0;
				(*this_shoot_mvty) = 0;
				(*this_sprite_y) = INACTIF;
			}			
		}
	}
}



// S_TRUE _ Collision  
/*
byte isCollision(int x1,int y1,byte h1,byte l1,int x2,int y2,byte h2,byte l2)
{
	if(x1 > x2+l2) return S_FALSE;
	if(x1+l1 < x2) return S_FALSE;
	if(y1 > y2+h2) return S_FALSE;
	if(y1+h1 < y2) return S_FALSE;
	
	return S_TRUE;
}*/

void desactivatePod(byte p,byte v)
{
	int calcx;
	int calcy;
	byte spriteRef;
	byte i;

	scrollObj[p].pod = scrollObj[p].pod & v;
	
	// Si tout les pods sont détruits, on désactive le tout !!
	if ( ( scrollObj[p].pod & 63) == 0 ) 
	{
		calcx = refx+((scrollObj[p].staticx)<<3);
		calcy = refy+((scrollObj[p].staticy)<<3);

		if (scrollObj[p].p==TILE_MOTHERSHIPV) spriteRef = 10; else spriteRef = 16;
		for (i=0;i<6;i++)		
			sprites[spriteRef+i].y = INVISIBLE;
		
		if (scrollObj[p].p==TILE_MOTHERSHIPV) sprites[23].y = INVISIBLE;
		else sprites[22].y = INVISIBLE;
		
		scrollObj[p].p = INACTIF;
		// Grosseux magouille pour effacer l'objet de l'écran !!
		//disable_nmi();
		put_frame_crop_H24(tiles_Pointer[TILE_BLANK],calcx,calcy,11,11);
		//enable_nmi();
		createNomoveObject((calcx<<3)+22,(calcy<<3)+22,NOMOVE_EXPLOSION);
		createNomoveObject((calcx<<3)+44,(calcy<<3)+44,NOMOVE_EXPLOSION);
		createNomoveObject((calcx<<3)+66,(calcy<<3)+66,NOMOVE_EXPLOSION);
		createNomoveObject((calcx<<3)+22,(calcy<<3)+66,NOMOVE_EXPLOSION);
		createNomoveObject((calcx<<3)+66,(calcy<<3)+22,NOMOVE_EXPLOSION);	
		nbMothershipLevel--;
		
		initRadar();		
		
	}
	
}

void checkCollision()
{
	byte i,j,k,dx,dy,l;
	int calcx,calcy;

	s_shoot *this_shoot;
	byte 	*this_shoot_sprno;
	char	*this_shoot_mvtx;
	char	*this_shoot_mvty;
	byte	*this_shoot_currentChar;

	sprite_t *this_sprite;
	byte 	 *this_sprite_x;
	byte 	 *this_sprite_y;
	
	s_alien	*this_alien;
	byte	*this_alien_sprno;
	byte	*this_alien_flag;
	
	sprite_t *this_sprite_alien;
	byte	*this_sprite_alien_x;
	byte	*this_sprite_alien_y;

	s_nomoveObject *this_nomoveObject;
	byte *this_nomoveObject_sprno;
	byte *this_nomoveObject_actif;
	
	sprite_t *this_sprite_nomoveObject;
	byte	*this_sprite_nomoveObject_x;
	byte	*this_sprite_nomoveObject_y;
	byte	*this_sprite_nomoveObject_pattern;
	byte	*this_sprite_nomoveObject_colour;

	s_ennemyBullet *this_ebullet;
	byte *this_ebullet_sprno;
	byte *this_ebullet_flag;
	
	sprite_t *this_sprite_ebullet;
	byte *this_sprite_ebullet_x;
	byte *this_sprite_ebullet_y;
	byte *this_sprite_ebullet_pattern;
//	byte *this_sprite_ebullet_colour;
	

	// Collision des objets par rapport au joueur !!
	// Collision avec décors
	if (
		(player.char_haut_gauche > 94) ||
		(player.char_haut_droite > 94) ||
		(player.char_bas_gauche > 94) ||
		(player.char_bas_droite > 94)
	)
		action = ACTION_LOOSE_LIFE;
	// Collision avec les sprites
	// Avec Alien
	for (j=0;j<MAXALIEN;j++)
	{
		this_alien = &alien[j];
		this_alien_flag = &this_alien->flags;
		if (((*this_alien_flag)&BUL_ACTIVE)!=0)
		{					
			this_alien_sprno = &this_alien->sprno;
			this_sprite_alien = &sprites[(*this_alien_sprno)];
			this_sprite_alien_x = &this_sprite_alien->x;
			this_sprite_alien_y = &this_sprite_alien->y;
					
			if (isCollision((*this_sprite_alien_x),(*this_sprite_alien_y),16,16,94+2,94+2,12,12) == S_TRUE)
			{
				action = ACTION_LOOSE_LIFE;
			}
		}
	}
	// Avec les nomoves
	for (j=0;j<MAXNOMOVE;j++)
	{
		this_nomoveObject = &nomoveObject[j];
		this_nomoveObject_actif = &this_nomoveObject->actif;
				
		if (((*this_nomoveObject_actif))==1)
		{
			this_nomoveObject_sprno = &this_nomoveObject->sprno;
			this_sprite_nomoveObject = &sprites[(*this_nomoveObject_sprno)];
			this_sprite_nomoveObject_x = &this_sprite_nomoveObject->x;
			this_sprite_nomoveObject_y = &this_sprite_nomoveObject->y;
			this_sprite_nomoveObject_pattern = &this_sprite_nomoveObject->pattern;
			this_sprite_nomoveObject_colour = &this_sprite_nomoveObject->colour;
					
			if ((*this_sprite_nomoveObject_pattern)!=NOMOVE_EXPLOSION)
			if (isCollision((*this_sprite_nomoveObject_x),(*this_sprite_nomoveObject_y),16,16,94+2,94+2,12,12) == S_TRUE)
			{
				if ((*this_sprite_nomoveObject_colour)!=6) // si on ne touche pas une explosion
				{
					action = ACTION_LOOSE_LIFE;
				}
			}
		}
	}
	// Avec les aliensbullet !!
	for (j=0;j<MAXENNEMYBULLET;j++)
	{
		this_ebullet = &ennemyBullet[j];
		this_ebullet_flag = &this_ebullet->flags;
		if (((*this_ebullet_flag)&BUL_ACTIVE)!=0)
		{		
			this_ebullet_sprno = &this_ebullet->sprno;
			this_sprite_ebullet = &sprites[(*this_ebullet_sprno)];
			this_sprite_ebullet_x = &this_sprite_ebullet->x;
			this_sprite_ebullet_y = &this_sprite_ebullet->y;	
			this_sprite_ebullet_pattern	= &this_sprite_ebullet->pattern;	
			
			if ((*this_sprite_ebullet_pattern)==(21<<2))
			{
				if (isCollision((*this_sprite_ebullet_x)+6,(*this_sprite_ebullet_y)+6,5,5,94+2,94+2,12,12) == S_TRUE)
				{
					action = ACTION_LOOSE_LIFE;
				}			
			}
			else
			{
				if (isCollision((*this_sprite_ebullet_x)+4,(*this_sprite_ebullet_y)+4,8,8,94+2,94+2,12,12) == S_TRUE)
				{
					action = ACTION_LOOSE_LIFE;
				}						
			}
			
		}		
	}
	
	
	// Collisions relative aux shoot du joueur
	dx=dy=0;
	for (i=0;i<4;i++)
	{
		this_shoot = &shoot[i];
		this_shoot_sprno = &this_shoot->sprno;
		this_shoot_mvtx = &this_shoot->mvtx;
		this_shoot_mvty = &this_shoot->mvty;
		this_shoot_currentChar = &this_shoot->currentChar;
		this_sprite = &sprites[(*this_shoot_sprno)];
		this_sprite_x = &this_sprite->x;
		this_sprite_y = &this_sprite->y;				

		if ( ((*this_shoot_mvtx)!=0) || ((*this_shoot_mvty)!=0) )
		{
			// Avec Alien
			for (j=0;j<MAXALIEN;j++)
			{
				this_alien = &alien[j];
				this_alien_flag = &this_alien->flags;
				if (((*this_alien_flag)&BUL_ACTIVE)!=0)
				{					
					this_alien_sprno = &this_alien->sprno;
					this_sprite_alien = &sprites[(*this_alien_sprno)];
					this_sprite_alien_x = &this_sprite_alien->x;
					this_sprite_alien_y = &this_sprite_alien->y;
					
					if (isCollision((*this_sprite_x),(*this_sprite_y),16,16,(*this_sprite_alien_x),(*this_sprite_alien_y),16,16) == S_TRUE)
					{
						(*this_alien_flag)=0;
						createNomoveObject((*this_sprite_alien_x),(*this_sprite_alien_y),NOMOVE_EXPLOSION);
						(*this_sprite_alien_y) = INACTIF;
						(*this_shoot_mvtx) = 0;
						(*this_shoot_mvty) = 0;
						(*this_sprite_y) = INACTIF;	
					}
				}
			}
			
			for (j=0;j<MAXNOMOVE;j++)
			{
				this_nomoveObject = &nomoveObject[j];
				this_nomoveObject_actif = &this_nomoveObject->actif;
				
				if (((*this_nomoveObject_actif))==1)
				{
					this_nomoveObject_sprno = &this_nomoveObject->sprno;
					this_sprite_nomoveObject = &sprites[(*this_nomoveObject_sprno)];
					this_sprite_nomoveObject_x = &this_sprite_nomoveObject->x;
					this_sprite_nomoveObject_y = &this_sprite_nomoveObject->y;
					this_sprite_nomoveObject_pattern = &this_sprite_nomoveObject->pattern;
					this_sprite_nomoveObject_colour = &this_sprite_nomoveObject->colour;
					
					if ((*this_sprite_nomoveObject_pattern)!=NOMOVE_EXPLOSION)
					if (isCollision((*this_sprite_x),(*this_sprite_y),16,16,(*this_sprite_nomoveObject_x),(*this_sprite_nomoveObject_y),16,16) == S_TRUE)
					{
						if ((*this_sprite_nomoveObject_colour)!=6) // si on ne touche pas une explosion
						{
							createNomoveObject((*this_sprite_nomoveObject_x),(*this_sprite_nomoveObject_y),NOMOVE_EXPLOSION);	
							(*this_nomoveObject_actif)=0;
							(*this_sprite_nomoveObject_y) = INACTIF;
							(*this_shoot_mvtx) = 0;
							(*this_shoot_mvty) = 0;
							(*this_sprite_y) = INACTIF;		
						}
					}
				}
			}
			}
			
			if ( ((*this_shoot_mvtx)!=0) || ((*this_shoot_mvty)!=0) )
			{
			if ((*this_shoot_currentChar)>94) // Avec élément du décor
			{				
				// Shoot direct
				if ((*this_shoot_currentChar) > 251)
				{
					if ((tankAnimationPointer<8)) // Tank visible
					{
						for (j=0;j<MAXSCROLLOBJ;j++)
						{						
							if ( (scrollObj[j].p == TILE_MOTHERSHIPV) || (scrollObj[j].p == TILE_MOTHERSHIPH) )
							{
								calcx = (refx+((scrollObj[j].staticx)<<3))<<3;
								calcy = (refy+((scrollObj[j].staticy)<<3))<<3;
									
								if (isCollision((*this_sprite_x),(*this_sprite_y),16,16,calcx,calcy,88,88) == S_TRUE)
								{				
									l=1;
									for (k=0;k<6;k++)
									{
										desactivatePod(j,255-l);
										l = l <<1;
									}		
								}
							}
						}
					}
				}
				else
				if ((*this_shoot_currentChar)>207) // Avec élément du décor destructible !!
				{					
					// On va vérifier qu'on est en contact avec un pod ou directement avec le mother ship
					for (j=0;j<MAXSCROLLOBJ;j++)
					{						
						if ( (scrollObj[j].p == TILE_MOTHERSHIPV) || (scrollObj[j].p == TILE_MOTHERSHIPH) )
						{
							 
								if ((scrollObj[j].pod & 128) == 128) // l'object est visible
								{
									// Récupération du point en haut à gauche en pixel du mothership
									calcx = (refx+((scrollObj[j].staticx)<<3))<<3;
									calcy = (refy+((scrollObj[j].staticy)<<3))<<3;
									
									if (isCollision((*this_sprite_x),(*this_sprite_y),16,16,calcx,calcy,88,88) == S_TRUE)
									{
										if  (scrollObj[j].p == TILE_MOTHERSHIPV)
										{
											// Test en suite du shoot de pod !
											l=1;
											for (k=0;k<6;k++)
											{
												dx = collisionv[k<<1];
												dy = collisionv[(k<<1)+1];

												if (isCollision((*this_sprite_x)+4,(*this_sprite_y)+4,8,8,calcx+dx,calcy+dy,16,16))
												{
													desactivatePod(j,255-l); 
													createNomoveObject((*this_sprite_x)+4,(*this_sprite_y)+4,NOMOVE_EXPLOSION);
													break;
												}

												l = l <<1;
											}
										}
										else
										if  (scrollObj[j].p == TILE_MOTHERSHIPH)
										{
											// Test ensuite du shoot de pod
											l=1;
											for (k=0;k<6;k++)
											{
												dx = collisionh[k<<1];
												dy = collisionh[(k<<1)+1];
											
												if (isCollision((*this_sprite_x)+4,(*this_sprite_y)+4,8,8,calcx+dx,calcy+dy,16,16))
												{
													desactivatePod(j,255-l); 
													createNomoveObject((*this_sprite_x)+4,(*this_sprite_y)+4,NOMOVE_EXPLOSION);
													break;
												}

												l = l <<1;
											}
										}
									}
								}
						}
					}
				}

			// On désactive le shoot
			shoot[i].mvtx = 0;
			shoot[i].mvty = 0;
			sprites[shoot[i].sprno].y = INACTIF;										
			}

		}
	}
}

byte returnShootPatternDirection(char mvtx,char mvty)
{
		if (mvtx==STATIQUE) return 19<<2;
		else if (mvty==STATIQUE) return 20<<2;
		else if ((mvtx==DROITE) && (mvty==BAS)) return 18<<2;
		else if ((mvtx==DROITE) && (mvty==HAUT)) return 17<<2;
		else if ((mvtx==GAUCHE) && (mvty==BAS)) return 17<<2;
		else if ((mvtx==GAUCHE) && (mvty==HAUT)) return 18<<2;
		
		return 19<<2;		 // de base vertical
}


void changePlayer(char dh,char dv,byte p1,byte p2)
{
	player.directionH = dh;
	player.directionV = dv;
	sprites[player.sprno1].pattern = p1;
	sprites[player.sprno2].pattern = p2;
}

void initStarfield()
{
	currentStarAnim = 19;
	
	stars[0].staticx =0;stars[0].staticy =0;//stars[0].pod =0;
	stars[1].staticx =10;stars[1].staticy =10;//stars[1].pod =0;
	stars[2].staticx =12;stars[2].staticy =20;//stars[2].pod =0;
	stars[3].staticx =20;stars[3].staticy =7;//stars[3].pod =0;
	stars[4].staticx =5;stars[4].staticy =22;//stars[4].pod =0;
	
}

void moveStarfield()
{
	byte so,moveUp,moveDown,moveLeft,moveRight,moveGlobal;
		
	s_star *this_scrollObj;
	char *this_scrollObj_staticx;
	char *this_scrollObj_staticy;
	byte current;
	byte current_char;
	
	moveUp = 0;
	moveDown = 0;
	moveLeft = 0;
	moveRight = 0;
	moveGlobal =0;
	
	// On anime
	
	if (player.directionV==HAUT)  
	{	
		/*
		currentStarAnim++; 		
		if ((currentStarAnim==13) || (currentStarAnim==21) || (currentStarAnim==29))
		{
			currentStarAnim-=3;moveUp=1;moveGlobal=1;
		}
		*/
		
		if ((currentStarAnim==12) || (currentStarAnim==20) || (currentStarAnim==28))
		{
			currentStarAnim-=2;moveUp=1;moveGlobal=1;
		}
		else
			currentStarAnim++; 
		
	}
	else
	if (player.directionV==BAS) 
	{		
		/*
		currentStarAnim--; 
		if ((currentStarAnim==9) || (currentStarAnim==17) || (currentStarAnim==25))
		{
			currentStarAnim+=3;moveDown=1;moveGlobal=1;
		}
		*/
		
		if ((currentStarAnim==10) || (currentStarAnim==18) || (currentStarAnim==26))
		{
			currentStarAnim+=2;moveDown=1;moveGlobal=1;
		}
		else
			currentStarAnim--;
	}
			
	if (player.directionH==DROITE)
	{		
		/*
		currentStarAnim-=8; 
		if ((currentStarAnim==2) || (currentStarAnim==3) || (currentStarAnim==4))
		{
			currentStarAnim+=24;moveRight=1;moveGlobal=1;
		}
		*/
		if ((currentStarAnim==10) || (currentStarAnim==11) || (currentStarAnim==12))
		{
			currentStarAnim+=16;moveRight=1;moveGlobal=1;
		}
		else
			currentStarAnim-=8; 		
	}
	else		
	if (player.directionH==GAUCHE)
	{
		/*
		currentStarAnim+=8; 
		if ((currentStarAnim==34) || (currentStarAnim==35) || (currentStarAnim==36))
		{
			currentStarAnim-=24;moveLeft=1;moveGlobal=1;
		}*/
		
		if ((currentStarAnim==26) || (currentStarAnim==27) || (currentStarAnim==28))
		{
			currentStarAnim-=16;moveLeft=1;moveGlobal=1;
		}	
		else
			currentStarAnim+=8;
	}

	for (so=0;so<5;so++)
	{
			this_scrollObj = &stars[so];

			this_scrollObj_staticx = &this_scrollObj->staticx;
			this_scrollObj_staticy = &this_scrollObj->staticy;
		
			if (moveGlobal==1) // On change la position de l'étoile
			{
				// On efface à l'ancienne position le cas échéant
				current_char = get_char((*this_scrollObj_staticx),(*this_scrollObj_staticy));
				if ( (current_char>8) && (current_char<31) )
					put_char((*this_scrollObj_staticx),(*this_scrollObj_staticy),92);	
						
				// On calcule les nouvelles coordonnées
				if (moveDown==1)  (*this_scrollObj_staticy)--; 
				else
				if (moveUp==1) (*this_scrollObj_staticy)++;
			
				if (moveRight==1) (*this_scrollObj_staticx)--; 
				else
				if (moveLeft==1) (*this_scrollObj_staticx)++;
			

				// On évite les débordements
				if ((*this_scrollObj_staticy)<0) (*this_scrollObj_staticy)=23;
				else
				if ((*this_scrollObj_staticy)>23) (*this_scrollObj_staticy)=0;

				if ((*this_scrollObj_staticx)<0) (*this_scrollObj_staticx)=23;
				else
				if ((*this_scrollObj_staticx)>23) (*this_scrollObj_staticx)=0;
			}
				
			// On trace si possible.
			current = get_char((*this_scrollObj_staticx),(*this_scrollObj_staticy));			
			if (( (current>8) && (current<31) )	|| 	(current==92))			
			{
				put_char((*this_scrollObj_staticx),(*this_scrollObj_staticy),currentStarAnim);
			}
	}
}

void initLevel(byte level)
{
	byte i;
	byte current;
	byte p;
	char v;
	char *levelTab;

	action = ACTION_NULL;
	nbMothershipLevel=0;
	tankAnimationPointer=0;
	tankAnimationSpeed=7; //1,3,7,15 etc etc ...
	motherShipVisible = -1;
	refx = -224/2;
	refy = -168/2;
	timer = 0;


	
	for (i=0;i<MAXSCROLLOBJ;i++)
		scrollObj[i].p = INACTIF;
		
	current = 0;
	p=0;
	v=0;
	levelTab = levels_Pointer[level-1];
	while (v!=-1)
	{
		v = *(levelTab+p);
		scrollObj[current].p = v;
		p++;
		v = *(levelTab+p);
		scrollObj[current].staticx = v;		
		p++;
		v = *(levelTab+p);
		scrollObj[current].staticy = v;
		current++;
		p++;
		v = *(levelTab+p);
	}
	
	player.directionH = STATIQUE;player.directionV = BAS;sprites[player.sprno1].pattern = 8;sprites[player.sprno2].pattern = 12;	
	initRadar();
}

void main_loop()
{
	char sp,sh;	// Shoot pattern + shoot number
	char s;
	byte i;
	
	sp=s=sh=0;

	mydelay = 1;
	while(workflow==INGAME) 
	{
		// Le point de référence se déplace à l'inverse d'un sprite

		// A voir si on garde !!
			if ((joypad_1 & UP) && (joypad_1 & LEFT)) changePlayer(GAUCHE,HAUT,15<<2,14<<2);
			else
			if ((joypad_1 & UP) && (joypad_1 & RIGHT)) changePlayer(DROITE,HAUT,9<<2,8<<2);
			else
			if ((joypad_1 & DOWN) && (joypad_1 & LEFT)) changePlayer(GAUCHE,BAS,13<<2,12<<2);
			else
			if ((joypad_1 & DOWN) && (joypad_1 & RIGHT)) changePlayer(DROITE,BAS,11<<2,10<<2);
			else
			if (joypad_1 & LEFT) changePlayer(GAUCHE,STATIQUE,24,28);
			else
			if (joypad_1 & RIGHT)  changePlayer(DROITE,STATIQUE,16,20);
			else
			if (joypad_1 & UP)  changePlayer(STATIQUE,HAUT,0,4);
			else
			if (joypad_1 & DOWN)  changePlayer(STATIQUE,BAS,8,12);
			
			if ( ( (joypad_1 & FIRE1) || (joypad_1 & FIRE2) ) && (player.timerShoot==0) ) 
			{
				for (i=0;i<2;i++) // 2 shoots !
				{
					sh=getFreeShoot();
					s=getFreeSprite();
					if ((sh!=-1) && (s!=-1) )
					{			
						if (i==0)
						{
							shoot[sh].mvtx = player.directionH;
							shoot[sh].mvty = player.directionV;
						}else
						{
							shoot[sh].mvtx = player.directionH*-1;
							shoot[sh].mvty = player.directionV*-1;						
						}
											
						sp = returnShootPatternDirection(player.directionH, player.directionV);
						// Réserver le sprite
						
						shoot[sh].sprno = s;
						sprites[s].colour = 14;
						sprites[s].x= sprites[player.sprno1].x;
						sprites[s].y= sprites[player.sprno1].y;						
						sprites[s].pattern = sp;
					}
				}
			
				player.timerShoot = 25;
			}
			
			if (player.timerShoot>0) player.timerShoot--;
			
					
		if ((timer&7)==0)
		{
					//32 = 1 écran en hozizontal en plus (= zone de 2 écrans au total)
			//64 = 2 écrans en horizontal en plus (= zone de 3 écrans au total)
			//24 = 1 écran en vertical en plus 

			if ( (player.directionH == GAUCHE) )refx+=1;
			else
			if ( (player.directionH == DROITE) )refx-=1; // (Total de 8 Ecrans en horizontal)
			
			if ( (player.directionV == HAUT) ) refy+=1;
			else
			if ( (player.directionV == BAS) ) refy-=1; //  (Total de 8 Ecrans en vertical)
			
			if (refx==-225) refx = 0;
			else
			if (refx==1) refx=-224;
			
			if (refy==-169) refy = 0;
			else
			if (refy==1) refy =-168;
			
			motherShipVisible = -1;
		}
		
		delay(1);
			
		if ((timer&7)==0)
		{

			renderScrollObj();	

			if ((timer&15)==0) renderRadar();			
			
			mydelay = 0; 
		}
				
		moveShoot();
		declencherNoMoveObject();
		declencherAlien();		
		for (i=0;i<MAXENNEMYBULLET;i++) updatebullet(i);
		
		if (tankAnimationSpeed>0)
		if (((timer&tankAnimationSpeed)==0) && (motherShipVisible!=-1))
		{	
			tankCurrentFrameV = tankAnimationV[tankAnimationPointer];
			sprites[23].pattern = tankCurrentFrameV;
			
			tankCurrentFrameH = tankAnimationH[tankAnimationPointer];
			sprites[22].pattern = tankCurrentFrameH;
			
			tankAnimationPointer++;
			if (tankAnimationPointer>39) tankAnimationPointer =0;
		}
		
		if ((timer&3)==0) {checkCollision();}		
				
		
		/*delay(mydelay);*/
		mydelay=1;
		render=0;
		
		timer++;
		if (currentFlicker<2) currentFlicker++; else currentFlicker=1;
		if (nbMothershipLevel==0) workflow = NEXT_LEVEL;
		
	}
}

void loadAPattern(char* p,char *c)
{
			screen_off;
			disable_nmi();			
			cls();
			load_patternrle(p);
			rle2vram(c,coltab);
			duplicate_pattern();			
			enable_nmi();
			screen_on();
}
void showAScreen(char* p,char *c,char *n)
{
			screen_off;
			disable_nmi();			
			cls();
			load_patternrle(p);
			
			rle2vram(c,coltab);
			duplicate_pattern();
			rle2vram(n,chrtab);				
			enable_nmi();
			screen_on();
			

}

void makeAPause()
{
		while ((!(joypad_1 & FIRE1)) && (!(joypad_1 & FIRE2)) ) {}
		while ((joypad_1 & FIRE1) || (joypad_2 & FIRE1)) {}
}

void main(void)
{	
	char test;	
	byte i,j;
	mynmi=0;
	go = 0;
	test=1;
	render = 1;


	
	screen_mode_2_bitmap();
	vdp_out(3,0x9f);
	vdp_out(4,0x3);
	
	while(1)
	{
		if (workflow==SHOW_SPLASH0)
		{
			showAScreen(SPLASH0_PATTERNRLE,SPLASH0_COLORRLE,SPLASH0_NAMERLE);
			center_string(20,"STARCOM IS A TRADEMARK OF");
			center_string(21,"COLLECTORVISION INDUSTRIES INC.");
			makeAPause();
			workflow = SHOW_STORY;
		
		}
		else
		if (workflow==SHOW_STORY)
		{
			showAScreen(SPLASH1_PATTERNRLE,SPLASH1_COLORRLE,SPLASH1_NAMERLE);
			center_string(15,"STARCOM IS A SPECIAL UNIT");
			center_string(16,"IN THE GROWING");
			center_string(17,"PLANETARY COMMUNITY");
			center_string(19,"THE MAIN OBSTACLE TO PEACE IS");
			center_string(20,"...");
			makeAPause();
			showAScreen(SPLASH2_PATTERNRLE,SPLASH2_COLORRLE,SPLASH2_NAMERLE);
			center_string(15,"THE SHADOW FORCE, AN ARMY");
			center_string(16,"LEAD BY"); 
			center_string(17,"THE SINISTER EMPEROR DARK.");
			center_string(18,"HIS PLAN IS TO");
			center_string(19,"RULE THE SOLAR SYSTEM.");
			center_string(21,"NOW, STOP HIM !");
			makeAPause();		
			workflow = SHOW_TITLE;			
		}
		else
		if (workflow==SHOW_TITLE)
		{
		
			showAScreen(TITLE_PATTERNRLE,TITLE_COLORRLE,TITLE_NAMERLE);
			makeAPause();		
			workflow = INGAME;
		}		
		else
		if (workflow==INGAME)
		{
				initEnnemyBullet();
				initScrollObj();
				initSprites();
				initNomoveObject();
				initStarfield();
				initPlayer();
				initAlien();
				initShoot();	
	
			screen_off;
			disable_nmi();
			cls();
			load_patternrle(PATTERNRLE);
			rle2vram(COLORRLE,coltab);
			duplicate_pattern();
			for (i=0;i<32;i++)
			for(j=0;j<24;j++)
				put_char(i,j,92);
			rle2vram(SPATTERNRLE,sprtab);
	
			renderHUD();	
			initLevel(2);
			screen_on;
			enable_nmi();
			
			traceSprite=1;			
			mynmi=1;
			main_loop();
		}
		else
		if (workflow==NEXT_LEVEL)
		{
				loadAPattern(SPLASH1_PATTERNRLE,SPLASH1_COLORRLE);
				initSprites();
				delay(1);
				mynmi=0;
				center_string(12,"GET READY FOR NEXT ZONE !");
				makeAPause();
					
				workflow=INGAME;
		}		
		else
		if (workflow==GAME_OVER)
		{
		}		
	}

}


void nmi()
{	
		if (mynmi==1)
		{
			if ((timer&1)==0) moveStarfield();
			
			if (traceSprite==1)
			{
				// J'ai mis le remplissage de bsprites directement dans le main_loop
				// A TESTER
				if (currentFlicker==2) put_vram (0x1b00,sprites,128); 
				else 
				{
					memcpyb(bsprites,sprites+16,64);
					memcpyb(bsprites+16,sprites,64);
					put_vram (0x1b00,bsprites,128);	
				}
			}

			player.char_haut_gauche = get_char(12,12);
			player.char_haut_droite = get_char(13,12);
			player.char_bas_gauche = get_char(12,13);
			player.char_bas_droite = get_char(13,13);
		}
	/******************************/
	/* NOUVEAU SYSTEME FLICKERING */
	/******************************/	
	/*
	nb_source = 32-p_source;
	memcpyb(bsprites,sprites+p_source,nb_source<<2);
	if (nb_source!=32) memcpyb(bsprites+32-p_source,sprites,(32-nb_source)<<2);			
	put_vram (0x1b00,bsprites,128);				
	p_source +=8; // 2,4,8,16 plus c'est gros moins ça flick, mais moins on affiche de sprite sur une ligne.
	if (p_source>31) p_source = 0;*/
	/**********************************/
	/* FIN NOUVEAU SYSTEME FLICKERING */
	/**********************************/	

					
}


/*
void NmiHandler(void)
    {

    if (!gNmiExecuted) // Check for reentrant NMI.
        {
        gNmiExecuted=1;

        // Acknowledge NMI (if required).

        // Do some stuff!

        gNmiExecuted=0;
        }
    else
        {
        // Acknowledge NMI (if required).
        // Change background colour or something visual.
        }
    }
*/

/*
void put_frame_fast(byte *tile,char x,char y,char w,char h)
{
	char tmp;
	
	if (x>31) return;
	if (y>23) return;
	
	tmp = x+w;
	
	if ( (x>=0) && ((x+w)<32) && ((y+h)<24) && (y>=0) )  // Et il n'y aura pas de clipping tout court
	{
		disable_nmi();
		put_frame0(tile,x,y,w,h);
		enable_nmi();
	}
	else // Il y aura un clipping à gauche
	{
		disable_nmi();
		put_frame(tile,x,y,w,h);
		enable_nmi();
	}
		
	return;
}

void put_frameS(byte *tile,char x,char y,char w,char h)
{
	char i;
	char cw; // calculated weight
	int offset_deplacement;
	char tmp;
	
	if (x>23) return;
	if (y>23) return;
	
	tmp = x+w;
	
	if (tmp<24) // Il n'y aura pas de clipping à droite
	{
		if ( (x>=0) && ((y+h)<24) && (y>=0) )  // Et il n'y aura pas de clipping tout court
		{
			disable_nmi();
			put_frame0(tile,x,y,w,h);
			enable_nmi();
		}
		else // Il y aura un clipping à gauche
		{
			disable_nmi();
			put_frame(tile,x,y,w,h);
			enable_nmi();
		}
		
		return;
	}
		offset_deplacement = 0;
	
		// Si on dépasse du crop
		// Il faut calculer la nouvelle largeur
		if ((tmp) > 24)
			cw = 24-x;
		else
			cw = w;
			
		if (cw>0)
		{
			
			for (i=0;i<h;i++)
			{
				tmp = y+i; // Ligne courant de l'écran à écrire
				if ((tmp)>23) return;
				if ((tmp)>=0)
				{				
					disable_nmi();
					put_vram(chrtab+((tmp)<<5)+x,tile+offset_deplacement,cw);	
					enable_nmi();					
				}					 
				offset_deplacement += w;
			}
			
		}			
}*/
